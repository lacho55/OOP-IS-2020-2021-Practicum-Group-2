# Седмица 3

## Днес ще бистрим тънките подробности относно вече загатнатата тема за шаблоните.

# Какво е шаблон?
---------------

### Функция или клас, която работи не с променливи от някакъв дефиниран тип, а с абстрактни променливи, се нарича шаблонна функция/клас. Когато някоя програма използва такава функция, тя трябва да изрично да уточни с какъв тип данни се използва. Един много прост пример - фунцкия, която намира по-голямата от две променливи.

```
#include<iostream>
using std::cout;
using std::endl;

template <class T>
T max(T a, T b)
{
    return (a > b ? a : b);
}

int main()
{
    cout<<max(3,6)<<" "<<max("Tri","Shest");
    return 0;
}
```

# За какво са нужни?
------------------

### Има един вечен проблем в програмирането.

## Как да работим по-малко?

<h3>Как да си свършваме работата с по-малко код? Същите задачи, но за по-малко време?\
Всички умни хора са мързеливи - ако не бяха, щяха да си вършат работата по трудния начин. Някои програмисти са умни. Умните програмисти са мързеливи. Най-най-основният начин да пишем по-малко код и да гледаме повече смешни снимки на котки е да спазваме DRY принципа.\
**D**on't **R**epeat **Y**ourself. <br>
Ако пишеш един и същи алгоритъм два пъти, единият път е било загуба на време.\
Винаги е по-хубаво, когато софтуерът не се повтаря. Това контрастира с хардуера, при който колкото повече - толкова повече. Така де, ако имаш два трактора, това е по-хубаво, отколкото ако имаш един трактор. Ама нямаш особена нужда от два учебника по Дискретна Математика, нали?^1^</h3>
<br><br>

# Шаблоните са начинът, по който C++ се справя с проблема с повтарянето.
<h3>
Горният код реализира алгоритъма за намиране на максимален измежду два елемента за всички съществуващи типове данни. За цели числа, нецели числа, цели неотрицателни числа, символи, низове, указатели. И каквото още има в C++. Но наистина удобното му е, че това ще важи и за всеки тип, който някога може да бъде написан. Точно така, ако утре си направиш клас желе и искаш да видиш кое е по-вкусно - малиново желе или желе от диня - ще можеш да го направиш, без никакъв проблем.<h3>

# Каква е уловката?
<h3>
Всичката магия става в компилатора. Той вижда как точно се използва шаблона - именно с кои типове ще се използва, и генерира (и компилира) код за всеки един отделен тип.
Ако искаш следният код да се изпълни:

````
Jelly Pink("Raspberry");
Jelly Green("Watermelon");
cout<<max(Pink, Green)<<endl;
````

То, трябва да е сигурно, че това ще се компилира:
````
Jelly max(Jelly a, Jelly b)
{
    return (a > b ? a : b);
}
````
Защото компилаторът точно до това ще сведе кода на програмата. В крайна сметка, класът Jelly трябва да има дефиниран опреатор >. Логично. Това може би е очевидно, но същата логика важи за всички шаблони и всяка употреба на класовете:

````
template <class T>
int get_x(T item)
{
    return T.x;
}

````
<h3>

### Шаблони на функции
Шаблоните на функции са специални функции, които могат да работят с много различни типове. Това ни позволява да създадем шаблон за функция, чиято функционалност може да бъде адаптирана към повече от един тип или клас данни, без да се повтаря код за всеки отделен тип.

В C ++ това може да се постигне, като се използват **параметри на шаблона**. Това е специален вид параметър, който може да се използва за предаване на тип като аргумент: точно както обикновените параметри на функцията могат да се използват за подаване на стойности към дадена функция, параметрите на шаблона позволяват да се подават типове на функции. 

Форматът за деклариране на шаблони на функции с **типови параметри** е:
```c++
template <class identifier> function_declaration;
template <typename identifier> function_declaration;
```
#### NB! И двата прототипа имат точно същото значение и се държат по същия начин.
#### Пример:
```c++
template <typename T>   // T e параметър на шаблона - това е типа, който по време на дефиницията на финкцията не искаме да посочваме
T max_of_two (T a, T b) {
    return (a > b? a : b);
}
```
Когато искам е да извикаме функцията за определен от нас тип, тогава:
```c++
int main()
{
    int first = 5, second = 12;
    
    cout << max_of_two <int> (first, second); // посочваме типа при извикването на функцията

    return 0;
}
```
Какво се случва зад колисите: Когато компилаторът срещне това извикване на шаблона, той използва шаблона, за да генерира автоматично функция, заменяща всяко срещане на типа T с типа, подаден като параметър (int в този случай), и след това я извиква. Този процес се изпълнява автоматично от компилатора и е невидим за програмиста.
#### Можем да добавяме няколко параметъра на шаблона => няколко различни типа
```c++
template <typename T, typename S>
void print_pair(T a, S b) {
	cout << a << " and type is: " << typeid(a).name() << endl;
	cout << b << " and type is: " << typeid(b).name() << endl;
}
```

### Шаблони на класове
Също така имаме възможност да пишем шаблони на класове, така че класът да има членове, които използват параметрите на шаблона като типове за тях.
#### Пример:
```c++
template <typename T>
class MyPair {
	T first;
	T second;
public:
	MyPair(T fst, T snd)
	{
		first = fst;
		second = snd;
	}
	void print() const
	{
		cout << "(" << first << ", " << second << ")\n";
	}
	T get_max();
};

// Aко не искаме да са inline

template<typename T>
T MyPair<T>::get_max() // <T> показва че Т-то, с което функцията работи и Т-то на класа са едни и същи
{
	return (first > second ? first : second);
}
```

#### Спецификация на шаблон - Ако искаме да дефинираме различна реализация на шаблон за конкретен тип, можем да дефинираме специализация на този шаблон за дадения тип. 
Когато създадем обект от шаблона с даден тип, компилатора първо проверява всички спецификации на шаблона, ако няма съвпадение на типовете, се генерера клас с дадения тип, в противен случай се използва спецификацията.
```c++
template <>
class MyPair <char>{
...
};
```
#### Може да се задават параметри по подразбиране на шаблона:
```c++
template <typename T=char> 
class MyPair {..};
```

От гледна точка на езика шаблоните не са нормални функции или класове. Те се компилират при поискване, което означава, че кодът на шаблонна функция не се компилира, докато не се наложи инстанция с конкретни типове. В този момент, когато се изисква инстанция, компилаторът генерира функцията, специално за тези аргументи на шаблона(типове).

#### Разделяне на интерфейс и реализация
Когато проектите ви нарастват, обикновено кодът на програмата се разделя в различни файлове. В тези случаи интерфейсът и реализацията обикновено са разделени в различни файлове. Интерфейсът - се слага във файл с разширение .h, а реализацията на отделните методи се слага във файл със разширение .срр.

**Тъй като шаблоните се компилират при необходимост, това налага ограничения за проекти с множество файлове: реализацията (дефиницията) на даден клас или функция на шаблона трябва да бъде в същия файл като неговата декларация(интерфейс). Това означава, че не можем да отделим интерфейса в отделен заглавен файл и че трябва да включим и интерфейса и реализацията във всеки файл, който използва шаблона.**
</h3>